---
title: 二叉搜索树
date: 2020-09-21 16:43:56
tags: 
- 二叉搜索树
- 算法
- 备赛
categories: 刷题日记
---

# 二叉搜索树

二叉搜索树，*Binary Search Tree*。

定义：它要么是一颗空树，要么在其左子树不为空的情况下，左子树上所有结点的值均小于它的根节点的值，在其右子树不为空的情况下，右子树上所有节点的值均大于根结点。

特点：结点之间有大小顺序，有快速查找的优势。

# 问题描述

将一个二叉搜索树变为累加树，即根节点等于其右子树所有结点的和，左节点等于根节点与右子树结点的和。

<!--more-->

例:

![](/images/bst.jpg)


## 解法

### 标准解法

显然简单的解法就是中序遍历二叉搜索树。先遍历右节点其次根节点，最后左节点。

### 我的解法

递归实现。依次处理左节点、右节点。

代码模板为：

~~~c++
int recursive(TreeNode* p)
{
    if(p->right)
    {
        if(!isLeafNode(p->right))
        {
            //
		}
        else
        {
            //
        }
	}
    else
        //
    if(p->left)
    {
        if(isLeafNode(p->right))
        {
            //
        }
        else
            //
    }
}
~~~

不是不可以做出来，但是很复杂，很多种情况需要考虑。依赖了样例的数据。

# 思考

* 一定要看清楚题目，理解题目意思。可以自己人脑运行一下样例。
* 面对一种数据结构，比如二叉树，尽最大努力去利用它的特性。比如二叉搜索树的性质，很明显可以用中序遍历来解题。
* 写完程序，进行分支检查。覆盖每一个if语句和else语句。毕竟比赛中没那么多样例程序给你跑。
* 算法题还是吃一点经验的，所以多做还是有好处。

